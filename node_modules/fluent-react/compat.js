/* fluent-react@0.7.0 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('fluent/compat'), require('react'), require('prop-types')) :
  typeof define === 'function' && define.amd ? define('fluent-react', ['exports', 'fluent/compat', 'react', 'prop-types'], factory) :
  (factory((global.FluentReact = {}),global.Fluent,global.React,global.PropTypes));
}(this, (function (exports,compat,react,PropTypes) { 'use strict';

  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    _setPrototypeOf(subClass.prototype, superClass && superClass.prototype);

    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.getPrototypeOf || function _getPrototypeOf(o) {
      return o.__proto__;
    };

    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  /*
   * `ReactLocalization` handles translation formatting and fallback.
   *
   * The current negotiated fallback chain of languages is stored in the
   * `ReactLocalization` instance in form of an iterable of `MessageContext`
   * instances.  This iterable is used to find the best existing translation for
   * a given identifier.
   *
   * `Localized` components must subscribe to the changes of the
   * `ReactLocalization`'s fallback chain.  When the fallback chain changes (the
   * `messages` iterable is set anew), all subscribed compontent must relocalize.
   *
   * The `ReactLocalization` class instances are exposed to `Localized` elements
   * via the `LocalizationProvider` component.
   */

  var ReactLocalization =
  /*#__PURE__*/
  function () {
    function ReactLocalization(messages) {
      _classCallCheck(this, ReactLocalization);

      this.contexts = new compat.CachedIterable(messages);
      this.subs = new Set();
    }
    /*
     * Subscribe a `Localized` component to changes of `messages`.
     */


    _createClass(ReactLocalization, [{
      key: "subscribe",
      value: function subscribe(comp) {
        this.subs.add(comp);
      }
      /*
       * Unsubscribe a `Localized` component from `messages` changes.
       */

    }, {
      key: "unsubscribe",
      value: function unsubscribe(comp) {
        this.subs.delete(comp);
      }
      /*
       * Set a new `messages` iterable and trigger the retranslation.
       */

    }, {
      key: "setMessages",
      value: function setMessages(messages) {
        this.contexts = new compat.CachedIterable(messages); // Update all subscribed Localized components.

        this.subs.forEach(function (comp) {
          return comp.relocalize();
        });
      }
    }, {
      key: "getMessageContext",
      value: function getMessageContext(id) {
        return compat.mapContextSync(this.contexts, id);
      }
    }, {
      key: "formatCompound",
      value: function formatCompound(mcx, msg, args) {
        var value = mcx.format(msg, args);

        if (msg.attrs) {
          var attrs = {};

          var _arr = Object.keys(msg.attrs);

          for (var _i = 0; _i < _arr.length; _i++) {
            var name = _arr[_i];
            attrs[name] = mcx.format(msg.attrs[name], args);
          }
        }

        return {
          value: value,
          attrs: attrs
        };
      }
      /*
       * Find a translation by `id` and format it to a string using `args`.
       */

    }, {
      key: "getString",
      value: function getString(id, args, fallback) {
        var mcx = this.getMessageContext(id);

        if (mcx === null) {
          return fallback || id;
        }

        var msg = mcx.getMessage(id);
        return mcx.format(msg, args);
      }
    }]);

    return ReactLocalization;
  }();
  function isReactLocalization(props, propName) {
    var prop = props[propName];

    if (prop instanceof ReactLocalization) {
      return null;
    }

    return new Error("The ".concat(propName, " context field must be an instance of ReactLocalization."));
  }

  /*
   * The Provider component for the `ReactLocalization` class.
   *
   * Exposes a `ReactLocalization` instance to all descendants via React's
   * context feature.  It makes translations available to all localizable
   * elements in the descendant's render tree without the need to pass them
   * explicitly.
   *
   *     <LocalizationProvider messages={…}>
   *         …
   *     </LocalizationProvider>
   *
   * The `LocalizationProvider` component takes one prop: `messages`.  It should
   * be an iterable of `MessageContext` instances in order of the user's
   * preferred languages.  The `MessageContext` instances will be used by
   * `ReactLocalization` to format translations.  If a translation is missing in
   * one instance, `ReactLocalization` will fall back to the next one.
   */

  var LocalizationProvider =
  /*#__PURE__*/
  function (_Component) {
    function LocalizationProvider(props) {
      var _this;

      _classCallCheck(this, LocalizationProvider);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(LocalizationProvider).call(this, props));
      var messages = props.messages;

      if (messages === undefined) {
        throw new Error("LocalizationProvider must receive the messages prop.");
      }

      if (!messages[Symbol.iterator]) {
        throw new Error("The messages prop must be an iterable.");
      }

      _this.l10n = new ReactLocalization(messages);
      return _this;
    }

    _createClass(LocalizationProvider, [{
      key: "getChildContext",
      value: function getChildContext() {
        return {
          l10n: this.l10n
        };
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(next) {
        var messages = next.messages;

        if (messages !== this.props.messages) {
          this.l10n.setMessages(messages);
        }
      }
    }, {
      key: "render",
      value: function render() {
        return react.Children.only(this.props.children);
      }
    }]);

    _inherits(LocalizationProvider, _Component);

    return LocalizationProvider;
  }(react.Component);
  LocalizationProvider.childContextTypes = {
    l10n: isReactLocalization
  };
  LocalizationProvider.propTypes = {
    children: PropTypes.element.isRequired,
    messages: isIterable
  };

  function isIterable(props, propName, componentName) {
    var prop = props[propName];

    if (Symbol.iterator in Object(prop)) {
      return null;
    }

    return new Error("The ".concat(propName, " prop supplied to ").concat(componentName, " must be an iterable."));
  }

  function withLocalization(Inner) {
    var WithLocalization =
    /*#__PURE__*/
    function (_Component) {
      function WithLocalization() {
        _classCallCheck(this, WithLocalization);

        return _possibleConstructorReturn(this, _getPrototypeOf(WithLocalization).apply(this, arguments));
      }

      _createClass(WithLocalization, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var l10n = this.context.l10n;

          if (l10n) {
            l10n.subscribe(this);
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          var l10n = this.context.l10n;

          if (l10n) {
            l10n.unsubscribe(this);
          }
        }
        /*
         * Rerender this component in a new language.
         */

      }, {
        key: "relocalize",
        value: function relocalize() {
          // When the `ReactLocalization`'s fallback chain changes, update the
          // component.
          this.forceUpdate();
        }
        /*
         * Find a translation by `id` and format it to a string using `args`.
         */

      }, {
        key: "getString",
        value: function getString(id, args, fallback) {
          var l10n = this.context.l10n;

          if (!l10n) {
            return fallback || id;
          }

          return l10n.getString(id, args, fallback);
        }
      }, {
        key: "render",
        value: function render() {
          var _this = this;

          return react.createElement(Inner, Object.assign( // getString needs to be re-bound on updates to trigger a re-render
          {
            getString: function getString() {
              return _this.getString.apply(_this, arguments);
            }
          }, this.props));
        }
      }]);

      _inherits(WithLocalization, _Component);

      return WithLocalization;
    }(react.Component);

    WithLocalization.displayName = "WithLocalization(".concat(displayName(Inner), ")");
    WithLocalization.contextTypes = {
      l10n: isReactLocalization
    };
    return WithLocalization;
  }

  function displayName(component) {
    return component.displayName || component.name || "Component";
  }

  /* eslint-env browser */
  var TEMPLATE = document.createElement("template");
  function parseMarkup(str) {
    TEMPLATE.innerHTML = str;
    return TEMPLATE.content;
  }

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in this directory.
   */
  // For HTML, certain tags should omit their close tag. We keep a whitelist for
  // those special-case tags.
  var omittedCloseTags = {
    area: true,
    base: true,
    br: true,
    col: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true // NOTE: menuitem's close tag should be omitted, but that causes problems.

  };

  // `omittedCloseTags` except that `menuitem` should still have its closing tag.

  var voidElementTags = _objectSpread({
    menuitem: true
  }, omittedCloseTags);

  // &amp;, &#0038;, &#x0026;.

  var reMarkup = /<|&#?\w+;/;
  /*
   * Prepare props passed to `Localized` for formatting.
   */

  function toArguments(props) {
    var args = {};
    var elems = {};

    var _arr = Object.entries(props);

    for (var _i = 0; _i < _arr.length; _i++) {
      var _arr$_i = _slicedToArray(_arr[_i], 2),
          propname = _arr$_i[0],
          propval = _arr$_i[1];

      if (propname.startsWith("$")) {
        var name = propname.substr(1);
        args[name] = propval;
      } else if (react.isValidElement(propval)) {
        // We'll try to match localNames of elements found in the translation with
        // names of elements passed as props. localNames are always lowercase.
        var _name = propname.toLowerCase();

        elems[_name] = propval;
      }
    }

    return [args, elems];
  }
  /*
   * The `Localized` class renders its child with translated props and children.
   *
   *     <Localized id="hello-world">
   *         <p>{'Hello, world!'}</p>
   *     </Localized>
   *
   * The `id` prop should be the unique identifier of the translation.  Any
   * attributes found in the translation will be applied to the wrapped element.
   *
   * Arguments to the translation can be passed as `$`-prefixed props on
   * `Localized`.
   *
   *     <Localized id="hello-world" $username={name}>
   *         <p>{'Hello, { $username }!'}</p>
   *     </Localized>
   *
   *  It's recommended that the contents of the wrapped component be a string
   *  expression.  The string will be used as the ultimate fallback if no
   *  translation is available.  It also makes it easy to grep for strings in the
   *  source code.
   */


  var Localized =
  /*#__PURE__*/
  function (_Component) {
    function Localized() {
      _classCallCheck(this, Localized);

      return _possibleConstructorReturn(this, _getPrototypeOf(Localized).apply(this, arguments));
    }

    _createClass(Localized, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var l10n = this.context.l10n;

        if (l10n) {
          l10n.subscribe(this);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var l10n = this.context.l10n;

        if (l10n) {
          l10n.unsubscribe(this);
        }
      }
      /*
       * Rerender this component in a new language.
       */

    }, {
      key: "relocalize",
      value: function relocalize() {
        // When the `ReactLocalization`'s fallback chain changes, update the
        // component.
        this.forceUpdate();
      }
    }, {
      key: "render",
      value: function render() {
        var l10n = this.context.l10n;
        var _this$props = this.props,
            id = _this$props.id,
            attrs = _this$props.attrs,
            children = _this$props.children;
        var elem = react.Children.only(children);

        if (!l10n) {
          // Use the wrapped component as fallback.
          return elem;
        }

        var mcx = l10n.getMessageContext(id);

        if (mcx === null) {
          // Use the wrapped component as fallback.
          return elem;
        }

        var msg = mcx.getMessage(id);

        var _toArguments = toArguments(this.props),
            _toArguments2 = _slicedToArray(_toArguments, 2),
            args = _toArguments2[0],
            elems = _toArguments2[1];

        var _l10n$formatCompound = l10n.formatCompound(mcx, msg, args),
            messageValue = _l10n$formatCompound.value,
            messageAttrs = _l10n$formatCompound.attrs; // The default is to forbid all message attributes. If the attrs prop exists
        // on the Localized instance, only set message attributes which have been
        // explicitly allowed by the developer.


        if (attrs && messageAttrs) {
          var localizedProps = {};

          var _arr2 = Object.entries(messageAttrs);

          for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
            var _arr2$_i = _slicedToArray(_arr2[_i2], 2),
                name = _arr2$_i[0],
                value = _arr2$_i[1];

            if (attrs[name]) {
              localizedProps[name] = value;
            }
          }
        } // If the wrapped component is a known void element, explicitly dismiss the
        // message value and do not pass it to cloneElement in order to avoid the
        // "void element tags must neither have `children` nor use
        // `dangerouslySetInnerHTML`" error.


        if (elem.type in voidElementTags) {
          return react.cloneElement(elem, localizedProps);
        } // If the message has a null value, we're only interested in its attributes.
        // Do not pass the null value to cloneElement as it would nuke all children
        // of the wrapped component.


        if (messageValue === null) {
          return react.cloneElement(elem, localizedProps);
        } // If the message value doesn't contain any markup nor any HTML entities,
        // insert it as the only child of the wrapped component.


        if (!reMarkup.test(messageValue)) {
          return react.cloneElement(elem, localizedProps, messageValue);
        } // If the message contains markup, parse it and try to match the children
        // found in the translation with the props passed to this Localized.


        var translationNodes = Array.from(parseMarkup(messageValue).childNodes);
        var translatedChildren = translationNodes.map(function (childNode) {
          if (childNode.nodeType === childNode.TEXT_NODE) {
            return childNode.textContent;
          } // If the child is not expected just take its textContent.


          if (!elems.hasOwnProperty(childNode.localName)) {
            return childNode.textContent;
          }

          var sourceChild = elems[childNode.localName]; // If the element passed as a prop to <Localized> is a known void element,
          // explicitly dismiss any textContent which might have accidentally been
          // defined in the translation to prevent the "void element tags must not
          // have children" error.

          if (sourceChild.type in voidElementTags) {
            return sourceChild;
          } // TODO Protect contents of elements wrapped in <Localized>
          // https://github.com/projectfluent/fluent.js/issues/184
          // TODO  Control localizable attributes on elements passed as props
          // https://github.com/projectfluent/fluent.js/issues/185


          return react.cloneElement(sourceChild, null, childNode.textContent);
        });
        return react.cloneElement.apply(void 0, [elem, localizedProps].concat(_toConsumableArray(translatedChildren)));
      }
    }]);

    _inherits(Localized, _Component);

    return Localized;
  }(react.Component);
  Localized.contextTypes = {
    l10n: isReactLocalization
  };
  Localized.propTypes = {
    children: PropTypes.element.isRequired
  };

  /*
   * @module fluent-react
   * @overview
   *

   * `fluent-react` provides React bindings for Fluent.  It takes advantage of
   * React's Components system and the virtual DOM.  Translations are exposed to
   * components via the provider pattern.
   *
   *     <LocalizationProvider messages={…}>
   *         <Localized id="hello-world">
   *             <p>{'Hello, world!'}</p>
   *         </Localized>
   *     </LocalizationProvider>
   *
   * Consult the documentation of the `LocalizationProvider` and the `Localized`
   * components for more information.
   */

  exports.LocalizationProvider = LocalizationProvider;
  exports.withLocalization = withLocalization;
  exports.Localized = Localized;
  exports.ReactLocalization = ReactLocalization;
  exports.isReactLocalization = isReactLocalization;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
